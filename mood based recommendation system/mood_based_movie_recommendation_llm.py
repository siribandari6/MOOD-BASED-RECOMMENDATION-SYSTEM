# -*- coding: utf-8 -*-
"""Mood_Based_Movie_Recommendation_LLM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cHdYTys-94DKQ_bIz985vID09NVoFraI

# ğŸ¬ LLM-Inspired Natural Language Mood-Based Movie Recommendation System

## ğŸ“Œ Project Overview

With the rapid growth of online streaming platforms, users are often overwhelmed
by the vast amount of available content. Traditional recommendation systems rely
heavily on historical user interactions, which leads to the **cold-start problem**
for new users.

This project presents an **LLM-inspired, mood-based movie recommendation system**
that uses **natural language input** to infer a user's emotional state and recommend
relevant movies **without requiring any prior user data**. The system is designed
to be lightweight, explainable, and reproducible for academic evaluation.

The system is implemented using:
- Python
- TMDB 5000 Movies Dataset
- Rule-based Natural Language Processing
- Content-based recommendation logic

This notebook serves as a **complete academic project submission**, including implementation, evaluation, and ethical considerations.
"""

print("Notebook ready")

import pandas as pd
import ast

import os
os.getcwd()

import os
os.makedirs("data", exist_ok=True)

import os
os.listdir("data")

import os
os.listdir("/content")

os.listdir("data")

"""## 1ï¸âƒ£ Problem Definition & Objective ğŸ¯

### a. Selected Project Track
**Project Track:** Content Recommendation Systems (AI / Machine Learning)

This project is developed under the **Content Recommendation Systems** track,
focusing on intelligent personalization using artificial intelligence techniques.
The system emphasizes delivering relevant content recommendations without relying
on historical user interaction data.

---

### b. Clear Problem Statement
Online streaming platforms offer access to thousands of movies, which often leads
to **choice overload** for users. Traditional recommendation systems rely heavily
on past user behavior such as watch history, ratings, or clicks.

For **new or first-time users**, this information is unavailable, resulting in the
**cold-start problem**, where recommendations are generic, random, or irrelevant.
This significantly reduces personalization and negatively impacts user experience.

---

### c. Real-World Relevance & Motivation
In real-world applications such as Netflix, Amazon Prime Video, and Disney+,
users frequently select content based on their **current emotional state** rather
than long-term viewing history.

This project is motivated by the need to design a system that can:
- Understand user intent through **natural language input**
- Infer the user's **mood or emotional context**
- Provide meaningful movie recommendations **without requiring prior user data**

Such a system is highly relevant for improving user engagement, satisfaction,
and personalization in modern digital entertainment platforms.



"""

import pandas as pd

movies = pd.read_csv("data/tmdb_5000_movies.csv", engine='python', on_bad_lines='skip')
movies.head()

"""## 2ï¸âƒ£ Data Understanding & Preparation ğŸ“Š

ğŸ“ **Dataset:** TMDB 5000 Movies Dataset (Public)  
ğŸŒ **Source:** The Movie Database (TMDB)  
ğŸ”’ **Privacy:** No personal or sensitive user data

The dataset contains movie metadata such as **title, genres, overview, ratings,
and popularity**. The `genres` column is preprocessed using `ast.literal_eval`
to extract clean genre labels for content-based filtering.

The dataset is well-structured with minimal noise, making it suitable for
recommendation system development.




"""

movies[['title', 'genres', 'overview', 'vote_average']].head()

[{"id": 28, "name": "Action"}, {"id": 12, "name": "Adventure"}]

import ast

def extract_genres(genre_str):
    genres = ast.literal_eval(genre_str)
    return [g['name'].lower() for g in genres]

movies['genre_list'] = movies['genres'].apply(extract_genres)

movies[['title', 'genre_list']].head()

"""## 3ï¸âƒ£ Model / System Design ğŸ—ï¸

ğŸ¤– **AI Approach:** Hybrid (Rule-based NLP + Recommendation System)  
ğŸ§  **Concept:** LLM-inspired reasoning

ğŸ”„ **Pipeline:**
User Text â†’ Mood Detection â†’ Moodâ€“Genre Mapping â†’ Movie Filtering â†’ Ranking

The design is inspired by LLM-style natural language understanding while ensuring
âœ… reproducibility, ğŸ’¸ cost-effectiveness, and âš–ï¸ ethical deployment.
The system is **LLM-ready** for future integration.



"""

mood_genre_map = {
    "happy": ["comedy", "family", "romance"],
    "sad": ["drama", "romance"],
    "angry": ["action", "thriller"],
    "relaxed": ["animation", "fantasy", "music"],
    "excited": ["adventure", "action", "science fiction"],
    "scared": ["horror", "mystery", "thriller"]
}

"""## 4ï¸âƒ£ Core Implementation âš™ï¸

ğŸ› ï¸ No model training is required.  
The system performs inference using:
- ğŸ—£ï¸ Rule-based mood extraction
- ğŸ­ Genre mapping
- ğŸ¬ Content-based filtering
- â­ Ranking by rating and popularity

All code runs **top-to-bottom without errors**, ensuring reproducibility.


"""

def recommend_movies_by_mood(mood, top_n=5):
    if mood not in mood_genre_map:
        return pd.DataFrame()

    target_genres = mood_genre_map[mood]

    filtered_movies = movies[movies['genre_list'].apply(
        lambda genres: any(g in genres for g in target_genres)
    )]

    recommendations = filtered_movies.sort_values(
        by='vote_average', ascending=False
    ).head(top_n)

    return recommendations[['title', 'genre_list', 'vote_average']]

recommend_movies_by_mood("happy")

"""### ğŸ—£ï¸ Natural Language Mood Extraction

Due to API access constraints, the system uses a **rule-based natural language understanding module**
to simulate **LLM-style reasoning** for mood detection.

This approach ensures:
- âœ… Reproducibility  
- âœ… Cost-effectiveness  
- âœ… Ethical deployment  

while preserving the **core recommendation logic**.

"""

def extract_mood_from_text(user_text):
    text = user_text.lower()

    mood_keywords = {
        "happy": ["happy", "joy", "fun", "cheerful", "excited"],
        "sad": ["sad", "lonely", "depressed", "down", "cry"],
        "angry": ["angry", "mad", "furious", "irritated"],
        "relaxed": ["calm", "relaxed", "peaceful", "chill", "stress"],
        "scared": ["scared", "afraid", "fear", "horror"],
        "excited": ["thrilled", "excited", "energetic"]
    }

    for mood, keywords in mood_keywords.items():
        for word in keywords:
            if word in text:
                return mood

    return "neutral"

extract_mood_from_text("I feel stressed and want something calm")

mood_to_genres = {
    "happy": ["Comedy", "Family", "Animation"],
    "sad": ["Drama", "Romance"],
    "angry": ["Action", "Thriller"],
    "relaxed": ["Drama", "Fantasy"],
    "excited": ["Adventure", "Action", "Science Fiction"],
    "scared": ["Horror", "Thriller"],
    "neutral": ["Drama"]
}

import ast

def extract_genre_names(genre_str):
    try:
        genres = ast.literal_eval(genre_str)
        return [g["name"] for g in genres]
    except:
        return []

movies["genre_names"] = movies["genres"].apply(extract_genre_names)
movies[["title", "genre_names"]].head()

"""### ğŸ”„ End-to-End Recommendation Flow

1. User enters natural language text
2. Mood is inferred
3. Relevant genres are selected
4. Movies are ranked by rating and popularity
5. Final recommendations are returned


"""

def recommend_movies(user_text, top_n=5):
    mood = extract_mood_from_text(user_text)
    preferred_genres = mood_to_genres.get(mood, ["Drama"])

    filtered = movies[movies["genre_names"].apply(
        lambda genres: any(g in genres for g in preferred_genres)
    )]

    ranked = filtered.sort_values(
        by=["vote_average", "popularity"],
        ascending=False
    )

    return mood, ranked[["title", "vote_average", "popularity"]].head(top_n)

mood, recommendations = recommend_movies(
    "I feel stressed and want something calm"
)

print("Detected mood:", mood)
recommendations

def generate_explanation(movie_title, mood):
    return (
        f"'{movie_title}' is recommended because it aligns well with a {mood} mood. "
        f"The movie belongs to genres commonly associated with this emotional state "
        f"and has received positive audience ratings."
    )

for title in recommendations["title"]:
    print(generate_explanation(title, mood))

"""## ğŸ’¬ Conversational Recommendation Extension

To enhance user experience, a **simple chatbot-style interface** is added.
It:
- Interacts with the user
- Collects preferences
- Refines recommendations dynamically

This conversational layer improves engagement without replacing the core system.


"""

def chatbot_recommender():
    print("ğŸ¬ Welcome to the Movie Recommendation Assistant!")

    user_text = input("How are you feeling today? ")
    mood = extract_mood_from_text(user_text)

    print(f"\nI detected that you're feeling **{mood}**.")

    preference = input("Do you prefer something light or intense? ").lower()

    mood, recommendations = recommend_movies(user_text)

    if preference == "light":
        recommendations = recommendations.head(3)
    elif preference == "intense":
        recommendations = recommendations.tail(3)

    print("\nHere are my recommendations:\n")

    for title in recommendations["title"]:
        print(generate_explanation(title, mood))

chatbot_recommender()

"""## 5ï¸âƒ£ Evaluation & Analysis ğŸ“ˆ

### ğŸ” Evaluation Approach
- Qualitative evaluation based on recommendation relevance
- Manual testing with different mood inputs
- Focus on cold-start effectiveness

### âœ… Observations
- System successfully infers moods from free-text input
- Recommendations align well with emotional context
- Works effectively without prior user history

## 6ï¸âƒ£ Ethical Considerations & Responsible AI âš–ï¸

- No personal user data is collected
- Dataset is publicly available and anonymized
- Rule-based NLP avoids opaque decision-making
- System is transparent and explainable

## 7ï¸âƒ£ Conclusion & Future Scope ğŸš€

### ğŸ¯ Conclusion
This project demonstrates a practical, explainable, and cold-startâ€“aware
mood-based movie recommendation system using natural language input.

### ğŸ”® Future Scope
- ğŸ¤– Integrate real LLMs
- ğŸ’¬ Add user feedback loops
- ğŸŒ Deploy using Streamlit
- ğŸµ Extend to other content domains
"""